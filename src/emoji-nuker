#!/usr/bin/env python3
"""
Emoji Nuker - Remove emojis from code files in a project directory.

A lightweight utility that scans your project directory and removes all emojis
from code files. It's especially useful for cleaning up emoji-laden comments,
log messages, or commit artifacts in codebases before production or archiving.

Usage:
    emoji-nuker /path/to/project

Author: Your Name
License: MIT
"""

import os
import re
import sys
import argparse
from pathlib import Path
from typing import Set, Pattern, Dict, List, Tuple, Optional


# Supported file extensions
CODE_EXTENSIONS: Set[str] = {
    ".py", ".js", ".ts", ".cpp", ".c", ".h", ".java", ".rb", ".go", ".rs",
    ".html", ".css", ".json", ".yml", ".yaml", ".sh", ".md", ".txt"
}

# Unicode emoji pattern (including variation selectors)
EMOJI_PATTERN: Pattern = re.compile(
    "["
    "\U0001F600-\U0001F64F"  # emoticons
    "\U0001F300-\U0001F5FF"  # symbols & pictographs
    "\U0001F680-\U0001F6FF"  # transport & map symbols
    "\U0001F1E0-\U0001F1FF"  # flags (iOS)
    "\U00002700-\U000027BF"  # dingbats
    "\U0001F900-\U0001F9FF"  # supplemental symbols and pictographs
    "\U00002600-\U000026FF"  # miscellaneous symbols
    "\U0001FA70-\U0001FAFF"  # symbols and pictographs extended-A
    "\U000025A0-\U000025FF"  # geometric shapes
    "\U0000FE00-\U0000FE0F"  # variation selectors
    "\U0001F3FB-\U0001F3FF"  # skin tone modifiers
    "]+", flags=re.UNICODE
)

# Unicode substitution mapping for common emojis
UNICODE_SUBSTITUTIONS: Dict[str, str] = {
    # Success/Status
    "âœ…": "âœ“",  # check mark
    "âŒ": "âœ—",  # ballot x
    "âš ï¸": "âš ",  # warning sign
    "â„¹ï¸": "â„¹",  # information source
    "ðŸ”": "ðŸ”",  # magnifying glass (keep as is, it's already unicode)
    "ðŸ“": "ðŸ“",  # folder (keep as is)
    "ðŸ“Š": "ðŸ“Š",  # bar chart (keep as is)
    
    # Arrows
    "âž¡ï¸": "â†’",  # right arrow
    "â¬…ï¸": "â†",  # left arrow
    "â¬†ï¸": "â†‘",  # up arrow
    "â¬‡ï¸": "â†“",  # down arrow
    "ðŸ”„": "â†»",  # clockwise arrows
    
    # Common symbols
    "ðŸš€": "â†‘",  # rocket -> up arrow
    "ðŸ’¡": "ðŸ’¡",  # light bulb (keep as is)
    "ðŸ”§": "ðŸ”§",  # wrench (keep as is)
    "âš¡": "âš¡",  # high voltage (keep as is)
    "ðŸ”¥": "ðŸ”¥",  # fire (keep as is)
    "ðŸ’¯": "100",  # hundred points
    "ðŸŽ¯": "â—Ž",  # bullseye
    "ðŸŽ‰": "ðŸŽ‰",  # party popper (keep as is)
    "ðŸŽŠ": "ðŸŽŠ",  # confetti ball (keep as is)
    
    # Programming/tech
    "ðŸ": "ðŸ",  # snake (keep as is)
    "ðŸ±â€ðŸ’»": "ðŸ’»",  # cat with laptop -> laptop
    "ðŸ±â€ðŸ‘¤": "ðŸ‘¤",  # ninja cat -> person
    "ðŸ±â€ðŸš€": "ðŸš€",  # astronaut cat -> rocket
    "ðŸ’»": "ðŸ’»",  # laptop (keep as is)
    "ðŸ–¥ï¸": "ðŸ–¥",  # desktop computer
    "ðŸ“±": "ðŸ“±",  # mobile phone (keep as is)
    "ðŸ”—": "ðŸ”—",  # link symbol (keep as is)
    "ðŸ”’": "ðŸ”’",  # lock (keep as is)
    "ðŸ”“": "ðŸ”“",  # unlock (keep as is)
    
    # Emotions/expressions
    "ðŸ˜…": "ðŸ˜…",  # grinning face with sweat (keep as is)
    "ðŸ˜Š": "ðŸ˜Š",  # smiling face with smiling eyes (keep as is)
    "ðŸ˜„": "ðŸ˜„",  # grinning face with smiling eyes (keep as is)
    "ðŸ˜Ž": "ðŸ˜Ž",  # smiling face with sunglasses (keep as is)
    "ðŸ¤”": "ðŸ¤”",  # thinking face (keep as is)
    "ðŸ˜±": "ðŸ˜±",  # face screaming in fear (keep as is)
    "ðŸ˜": "ðŸ˜",  # smiling face with heart-eyes (keep as is)
    
    # Objects
    "ðŸ“": "ðŸ“",  # memo (keep as is)
    "ðŸ“„": "ðŸ“„",  # page facing up (keep as is)
    "ðŸ“‚": "ðŸ“‚",  # open file folder (keep as is)
    "ðŸ—‚ï¸": "ðŸ—‚",  # card index dividers
    "ðŸ“Œ": "ðŸ“Œ",  # pushpin (keep as is)
    "ðŸ“": "ðŸ“",  # round pushpin (keep as is)
    "ðŸ”–": "ðŸ”–",  # bookmark (keep as is)
    
    # Time
    "â°": "â°",  # alarm clock (keep as is)
    "â±ï¸": "â±",  # stopwatch
    "â²ï¸": "â²",  # timer clock
    "ðŸ•": "ðŸ•",  # one o'clock (keep as is)
    "ðŸ•™": "ðŸ•™",  # ten o'clock (keep as is)
    
    # Weather
    "â˜€ï¸": "â˜€",  # sun
    "ðŸŒ™": "ðŸŒ™",  # new moon (keep as is)
    "â˜ï¸": "â˜",  # cloud
    "ðŸŒ§ï¸": "ðŸŒ§",  # cloud with rain
    "âš¡": "âš¡",  # high voltage (keep as is)
    
    # Numbers
    "1ï¸âƒ£": "1",
    "2ï¸âƒ£": "2", 
    "3ï¸âƒ£": "3",
    "4ï¸âƒ£": "4",
    "5ï¸âƒ£": "5",
    "6ï¸âƒ£": "6",
    "7ï¸âƒ£": "7",
    "8ï¸âƒ£": "8",
    "9ï¸âƒ£": "9",
    "0ï¸âƒ£": "0",
    
    # Letters
    "ðŸ…°ï¸": "A",
    "ðŸ…±ï¸": "B",
    "ðŸ†Ž": "AB",
    "ðŸ†‘": "CL",
    "ðŸ†’": "COOL",
    "ðŸ†“": "FREE",
    "ðŸ†”": "ID",
    "ðŸ†•": "NEW",
    "ðŸ†–": "NG",
    "ðŸ†—": "OK",
    "ðŸ†˜": "SOS",
    "ðŸ†™": "UP",
    "ðŸ†š": "VS",
}


class EmojiSubstitution:
    """Handles emoji detection and substitution with Unicode alternatives."""
    
    def __init__(self, substitute: bool = False, interactive: bool = False, label: bool = False):
        self.substitute = substitute
        self.interactive = interactive
        self.label = label
        self.substitutions_made: List[Tuple[str, str, str]] = []  # (emoji, unicode, file_path)
        self.emojis_found: Dict[str, List[str]] = {}  # emoji -> list of files
    
    def find_emoji_substitution(self, emoji: str) -> Optional[str]:
        """Find a Unicode substitution for an emoji."""
        return UNICODE_SUBSTITUTIONS.get(emoji)
    
    def process_content(self, content: str, file_path: str) -> str:
        """Process content and either substitute or collect emojis."""
        if self.substitute:
            return self._substitute_emojis(content, file_path)
        else:
            return self._collect_emojis(content, file_path)
    
    def _substitute_emojis(self, content: str, file_path: str) -> str:
        """Replace emojis with Unicode alternatives or label/remove."""
        new_content = content
        emojis = EMOJI_PATTERN.findall(content)
        for emoji in emojis:
            substitution = self.find_emoji_substitution(emoji)
            if substitution and substitution != emoji:
                new_content = new_content.replace(emoji, substitution)
                self.substitutions_made.append((emoji, substitution, file_path))
                print(f"\033[32mâœ“ Replaced '{emoji}' with '{substitution}' in {file_path}\033[0m")
            elif self.label:
                label = f"[emoji:U+{ord(emoji):04X}]"
                new_content = new_content.replace(emoji, label)
                self.substitutions_made.append((emoji, label, file_path))
                print(f"\033[36mâ„¹ Labeled '{emoji}' as '{label}' in {file_path}\033[0m")
            else:
                new_content = new_content.replace(emoji, "")
                print(f"\033[33mâš  Removed '{emoji}' (no substitution/label) from {file_path}\033[0m")
        return new_content
    
    def _collect_emojis(self, content: str, file_path: str) -> str:
        """Collect emojis for later review without modifying content."""
        emojis = EMOJI_PATTERN.findall(content)
        
        for emoji in emojis:
            if emoji not in self.emojis_found:
                self.emojis_found[emoji] = []
            if file_path not in self.emojis_found[emoji]:
                self.emojis_found[emoji].append(file_path)
        
        return content
    
    def show_substitution_summary(self):
        """Show summary of substitutions made."""
        if self.substitutions_made:
            print(f"\n\033[34mðŸ“Š Substitution Summary:\033[0m")
            for emoji, substitution, file_path in self.substitutions_made:
                print(f"   '{emoji}' â†’ '{substitution}' in {file_path}")
    
    def show_emoji_suggestions(self):
        """Show emojis found with potential substitutions."""
        if not self.emojis_found:
            return
        
        print(f"\n\033[34mðŸ“‹ Emojis Found (Potential Substitutions):\033[0m")
        for emoji, files in self.emojis_found.items():
            substitution = self.find_emoji_substitution(emoji)
            if substitution:
                print(f"\n\033[32mâœ“ '{emoji}' â†’ '{substitution}'\033[0m")
            else:
                print(f"\n\033[33mâš  '{emoji}' â†’ (no substitution available)\033[0m")
            
            for file_path in files:
                print(f"   ðŸ“„ {file_path}")


def remove_emojis_from_file(file_path: Path, substitution_handler: EmojiSubstitution) -> bool:
    """
    Remove emojis from a single file.
    
    Args:
        file_path: Path to the file to process
        substitution_handler: Handler for emoji substitution logic
        
    Returns:
        True if the file was modified, False otherwise
    """
    try:
        # Read file content
        with file_path.open("r", encoding="utf-8") as f:
            content = f.read()
        
        # Process content based on substitution mode
        new_content = substitution_handler.process_content(content, str(file_path))
        
        # Only write if content changed
        if content != new_content:
            with file_path.open("w", encoding="utf-8") as f:
                f.write(new_content)
            print(f"\033[32mâœ“ Cleaned: {file_path}\033[0m")
            return True
        else:
            print(f"\033[34mâ„¹ No emojis found: {file_path}\033[0m")
            return False
            
    except UnicodeDecodeError:
        print(f"\033[33mâš  Skipping binary file: {file_path}\033[0m")
        return False
    except PermissionError:
        print(f"\033[31mâœ— Permission denied: {file_path}\033[0m")
        return False
    except Exception as e:
        print(f"\033[31mâœ— Failed to process {file_path}: {e}\033[0m")
        return False


def clean_directory(root: Path, verbose: bool = False, substitution_handler: Optional[EmojiSubstitution] = None) -> tuple[int, int]:
    """
    Recursively clean all code files in a directory.
    
    Args:
        root: Root directory to scan
        verbose: Enable verbose output
        substitution_handler: Handler for emoji substitution logic
        
    Returns:
        Tuple of (files_processed, files_modified)
    """
    if substitution_handler is None:
        substitution_handler = EmojiSubstitution()
    
    files_processed = 0
    files_modified = 0
    
    if verbose:
        print(f"Scanning directory: {root}")
        print(f"Supported extensions: {', '.join(sorted(CODE_EXTENSIONS))}")
    
    for path in root.rglob("*"):
        if path.is_file() and path.suffix in CODE_EXTENSIONS:
            files_processed += 1
            if remove_emojis_from_file(path, substitution_handler):
                files_modified += 1
    
    return files_processed, files_modified


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Remove emojis from code files in a project directory.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  emoji-nuker /path/to/project           # Remove all emojis
  emoji-nuker .                          # Clean current directory
  emoji-nuker --verbose /path            # Verbose output
  emoji-nuker --substitute /path         # Replace emojis with Unicode alternatives
  emoji-nuker --interactive /path        # Show emoji suggestions without modifying files
  emoji-nuker --label /path              # Replace emojis with a label like [emoji:U+XXXX] if no substitution exists
        """
    )
    
    parser.add_argument(
        "directory",
        type=str,
        help="Path to the root of the project directory"
    )
    
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose output"
    )
    
    parser.add_argument(
        "--substitute", "-s",
        action="store_true",
        help="Replace emojis with Unicode alternatives instead of removing them"
    )
    
    parser.add_argument(
        "--interactive", "-i",
        action="store_true",
        help="Show emoji suggestions without modifying files"
    )
    
    parser.add_argument(
        "--label", "-l",
        action="store_true",
        help="Replace emojis with a label like [emoji:U+XXXX] if no substitution exists"
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version="emoji-nuker 1.0.0"
    )
    
    args = parser.parse_args()
    
    # Validate directory
    root_path = Path(args.directory)
    if not root_path.exists():
        print(f"\033[31mâœ— Error: Directory does not exist: {root_path}\033[0m")
        sys.exit(1)
    
    if not root_path.is_dir():
        print(f"\033[31mâœ— Error: Not a directory: {root_path}\033[0m")
        sys.exit(1)
    
    # Create substitution handler
    substitution_handler = EmojiSubstitution(
        substitute=args.substitute,
        interactive=args.interactive,
        label=args.label
    )
    
    # Process files
    try:
        files_processed, files_modified = clean_directory(root_path, args.verbose, substitution_handler)
        
        print(f"\nSummary:")
        print(f"   Files processed: {files_processed}")
        print(f"   Files modified: {files_modified}")
        
        # Show appropriate summary based on mode
        if args.substitute:
            substitution_handler.show_substitution_summary()
        elif args.interactive:
            substitution_handler.show_emoji_suggestions()
        else:
            if files_modified > 0:
                print(f"\033[32mâœ“ Successfully removed emojis from {files_modified} files!\033[0m")
            else:
                print("\033[34mâ„¹ No files were modified.\033[0m")
            
    except KeyboardInterrupt:
        print("\n\033[33mâš  Operation cancelled by user\033[0m")
        sys.exit(1)
    except Exception as e:
        print(f"\033[31mâœ— Unexpected error: {e}\033[0m")
        sys.exit(1)


if __name__ == "__main__":
    main() 